# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Evalute the Integrand Function
#' 
#' Analog to [q()], but here the model is set with beta distribution.
#' 
#' @seealso [q()]
#' 
q_beta <- function(x, g, N, a, b, w0 = 0.1) {
    .Call(`_nj_q_beta`, x, g, N, a, b, w0)
}

#' Evaluate the Integral Numerically
#' 
#' Analog to [intq()], but here the model is set with beta distribution.
#' 
#' @seealso [intq()]
#' 
intq_beta <- function(g, N, a, b, ub, lb, n = 10L, w0 = 0.1) {
    .Call(`_nj_intq_beta`, g, N, a, b, ub, lb, n, w0)
}

#' Simulate Samples of Variable Y
#' 
#' Analog to [sim_Y()], but here the model is set with beta distribution.
#' 
#' @seealso [sim_Y()]
#' 
sim_Y_beta <- function(g, N, a, b, L, w0 = 0.1) {
    .Call(`_nj_sim_Y_beta`, g, N, a, b, L, w0)
}

#' Evaluate the Objective Function
#' 
#' Analog to [f_obj()], but here the model is set with beta distribution.
#' 
#' @seealso [f_obj()]
#' 
f_obj_beta <- function(g, N, a, b, L, moments, w0 = 0.1) {
    .Call(`_nj_f_obj_beta`, g, N, a, b, L, moments, w0)
}

#' Evaluate Gradient of the Objective Function
#' 
#' Analog to [df_obj()], but here the model is set with beta distribution.
#' 
#' @seealso [df_obj()]
#' 
df_obj_beta <- function(g, N, a, b, L, moments, stepsize, w0 = 0.1) {
    .Call(`_nj_df_obj_beta`, g, N, a, b, L, moments, stepsize, w0)
}

#' Stochastic Approximation
#' 
#' Analog to [sa()], but here the model is set with beta distribution.
#' 
#' @seealso [sa()]
#' 
sa_beta <- function(theta0, Theta, stepsize, L, moments, G = 200L) {
    .Call(`_nj_sa_beta`, theta0, Theta, stepsize, L, moments, G)
}

#' Compute the first four (central) moments
#' 
#' `mom()` compute the first moment, the second to fourth central moments.
#' 
#' @param samples A vector of the samples.
#' @returns A vector of the first four (central) moments. 
#'   \deqn{(E[x],E[(x-E[x])^2],E[(x-E[x])^3],E[(x-E[x])^4])}
#' @examples
#' mom(rnorm(100,0,1))
#' 
#' @export
#' 
mom <- function(samples) {
    .Call(`_nj_mom`, samples)
}

#' Evaluate the Integrand Function
#' 
#' Compute the integrand function of the model which is described by the 
#' following equation:
#' \deqn{
#'   \beta(\alpha) = 1 - e^{\int_{-\infty}^{\alpha}q(x)dx},
#' }
#' where \eqn{\alpha \sim \mathcal{N}(\mu,\sigma^2)},
#' the integrand is
#' \deqn{
#'   q(x) \equiv \frac{g(N-1)F^{N-2}(x)f(x)x}{(w_0 + gF^{N-1}(x))(x-1)}.
#' }
#' and \eqn{f(x)} and \eqn{F(x)} are the PDF and CDF of the normal 
#' distribution \eqn{\mathcal{N}(\mu,\sigma^2)}, respectively.
#' 
#' @param x A scalar variable.
#' @param g The parameter \eqn{g}.
#' @param N The parameter \eqn{N}, it should be larger than 2.
#' @param mu The parameter \eqn{\mu}, mean of the normal distribution.
#' @param sigma The parameter \eqn{\sigma}, standard deviation of the normal
#' distribution.
#' @param w0 The parameter \eqn{w_0}, default to 0.1.
#' 
#' @returns A scalar value.
#' 
#' @examples
#' q(0.1, 0.2, 3.5, 0.5, 0.1)
#' 
#' @export
#' 
q <- function(x, g, N, mu, sigma, w0 = 0.1) {
    .Call(`_nj_q`, x, g, N, mu, sigma, w0)
}

#' Evaluate the Integral Numerically
#' 
#' Evaluate the integral with given upper and lower bounds by using 
#' trapezoidal rule.
#' 
#' @param g The parameter \eqn{g}.
#' @param N The parameter \eqn{N}, it should be larger than 2.
#' @param mu The parameter \eqn{\mu}, mean of the normal distribution.
#' @param sigma The parameter \eqn{\sigma}, standard deviation of the normal
#' distribution.
#' @param ub Upper bound of the integral, \eqn{\int_{lb}^{ub}q(x)dx}.
#' @param lb Lower bound of the integral.
#' @param n Segments to divide when computing the integral numerically.
#' @param w0 The parameter \eqn{w_0}, default to 0.1.
#' 
#' @returns A scalar value.
#' @seealso [q()]
#' @examples
#' intq(0.2, 3.5, 0.5, 0.1, 0.4, 0)
#' 
#' @export
#' 
intq <- function(g, N, mu, sigma, ub, lb, n = 10L, w0 = 0.1) {
    .Call(`_nj_intq`, g, N, mu, sigma, ub, lb, n, w0)
}

#' Simulate Samples of Variable Y
#' 
#' Simulate samples of the variable
#' \deqn{
#'   Y \equiv \log(1 - \beta(\alpha)), Y = \int_{-\infty}^X q(x) dx.
#' }
#' where \eqn{\quad X \equiv \alpha}.
#' 
#' @param g The parameter \eqn{g}.
#' @param N The parameter \eqn{N}, it should be larger than 2.
#' @param mu The parameter \eqn{\mu}, mean of the normal distribution.
#' @param sigma The parameter \eqn{\sigma}, standard deviation of the normal
#' distribution.
#' @param L Length of the samples to generate.
#' @param w0 The parameter \eqn{w_0}, default to 0.1.
#' 
#' @returns A vector of simulated \eqn{Y} samples.
#' @examples
#' sim_Y(0.2, 3.5, 0.5, 0.1, 100)
#' 
#' @export
#' 
sim_Y <- function(g, N, mu, sigma, L, w0 = 0.1) {
    .Call(`_nj_sim_Y`, g, N, mu, sigma, L, w0)
}

#' Evaluate the Objective Function
#' 
#' Evaluate the objective function, i.e., the error function. First, generate
#' a sequence of samples by simulation under the given parameters. Then,
#' compute the first four (central) moments of the simulated samples. Last,
#' compute the differences between the true sample moments and the simulated
#' sample moments.
#' 
#' @param g The parameter \eqn{g}.
#' @param N The parameter \eqn{N}, it should be larger than 2.
#' @param mu The parameter \eqn{\mu}, mean of the normal distribution.
#' @param sigma The parameter \eqn{\sigma}, standard deviation of the normal
#' distribution.
#' @param L Length of the samples to generate.
#' @param moments A vector of the true sample moments, 1st moment,
#' 2nd - 4th central moments.
#' @param w0 The parameter \eqn{w_0}, default to 0.1.
#' 
#' @returns A scalar value.
#' @examples
#' Y = sim_Y(0.2, 3.5, 0.5, 0.1, 1000)
#' moments = mom(Y)
#' f_obj(0.3, 3, 0.4, 0.05, 1000, moments)
#' 
#' @export
#' 
f_obj <- function(g, N, mu, sigma, L, moments, w0 = 0.1) {
    .Call(`_nj_f_obj`, g, N, mu, sigma, L, moments, w0)
}

#' Evaluate Gradient of the Objective Function
#' 
#' Evaluate gradient of the objective function by Finite Difference (FD).
#' 
#' @param g The parameter \eqn{g}.
#' @param N The parameter \eqn{N}, it should be larger than 2.
#' @param mu The parameter \eqn{\mu}, mean of the normal distribution.
#' @param sigma The parameter \eqn{\sigma}, standard deviation of the normal
#' distribution.
#' @param L Length of the samples to generate.
#' @param moments A vector of the true sample moments, 1st moment,
#' 2nd - 4th central moments.
#' @param stepsize A vector of four scalars, step size for each of the 
#' four parameters.
#' @param w0 The parameter \eqn{w_0}, default to 0.1.
#' 
#' @returns A vector of four partial derivatives.
#' @examples
#' Y = sim_Y(0.2, 3.5, 0.5, 0.1, 1000)
#' moments = mom(Y)
#' stepsize = rep(0.01, 4)
#' df_obj(0.3, 3, 0.4, 0.05, 1000, moments, stepsize)
#' 
#' @export
#' 
df_obj <- function(g, N, mu, sigma, L, moments, stepsize, w0 = 0.1) {
    .Call(`_nj_df_obj`, g, N, mu, sigma, L, moments, stepsize, w0)
}

#' Evaluate Single Partial Derivative
#' 
#' Evaluate single partial derivative of the objective function by
#' Finite Difference (FD).
#' 
#' @param i An integer, 1,2,3,4 corresponding to \eqn{g, N, \mu, \sigma}
#' respectively.
#' @param theta A vector of the parameters \eqn{g, N, \mu, \sigma}.
#' @param L Length of the samples to generate.
#' @param moments A vector of the true sample moments, 1st moment,
#' 2nd - 4th central moments.
#' @param h A scalar, step size for the parameter change.
#' @param G A integer, default to 10, number of replications.
#' @param w0 The parameter \eqn{w_0}, default to 0.1.
#' 
#' @returns A scalar.
#' @examples
#' theta = c(0.3, 3, 0.4, 0.05)
#' Y = sim_Y(0.2, 3.5, 0.5, 0.1, 1000)
#' moments = mom(Y)
#' df_obj2(2, theta, 1000, moments)
#' 
df_obj2 <- function(i, theta, L, moments, h = 0.01, G = 10L, w0 = 0.1) {
    .Call(`_nj_df_obj2`, i, theta, L, moments, h, G, w0)
}

#' Project Parameters back to the Feasible Space
#' 
#' Project parameters back to the feasible space.
#' 
#' @param theta A vector of the parameters.
#' @param Theta A matrix each row of which have two scalars, 
#' first: lower bound, second: upper bound.
#' 
#' @returns A vector.
#' @examples
#' theta = c(-0.3, 3, 0.4, 0.05)
#' Theta = matrix(c(0,10, 2,10, 0.1,0.9, 0.01,0.4), 
#'                  nrow=4, ncol=2, byrow=TRUE)
#' project(theta, Theta)
#' 
#' @export
#' 
project <- function(theta, Theta) {
    .Call(`_nj_project`, theta, Theta)
}

#' More Fine Projection
#' 
#' Fine tune the mean and standard deviation of the normal distribution,
#' considering that it should not produce random variable smaller than 0,
#' or larger than 1.
#' 
#' @param theta A vector of the parameters.
#' @param Theta A matrix each row of which have two scalars, 
#' first: lower bound, second: upper bound.
#' 
#' @returns A vector.
#' @examples
#' theta = c(-0.3, 3, 0.4, 1)
#' Theta = matrix(c(0,10, 2,10, 0.1,0.9, 0.01,0.4), 
#'                  nrow=4, ncol=2, byrow=TRUE)
#' project2(theta, Theta)
#' 
#' @export
#' 
project2 <- function(theta, Theta) {
    .Call(`_nj_project2`, theta, Theta)
}

#' Stochastic Approximation
#' 
#' Search the optimal parameters by Stochastic Approximation (SA). That is
#' to find the parameters that minimize the objective (error) function.
#' 
#' @param theta0 A vector of four scalars, i.e., the initial guess of the
#' parameters' value.
#' @param Theta A matrix of \eqn{4\times 2}, feasible space of the parameters.
#' Each row have two scalars, first: lower bound, second: upper bound.
#' @param stepsize A vector of four scalars, step size for each parameter.
#' @param L An integer, sample length used for each simulation embedded in the
#' SA searching.
#' @param moments A vector of the true sample moments, 1st moment,
#' 2nd - 4th central moments.
#' @param G An integer, number of searching iterations.
#' 
#' @returns A matrix of the search trajectory, the first four columns
#' corresponding to the four parameters, and the last column corresponding
#' to the objective function value.
#' @examples
#' Y_sim = sim_Y(0.2, 3.5, 0.5, 0.1, 1000)    # 仿真生成1,000个模型样本
#' L = length(Y_sim)  
#' moments = mom(Y_sim)                       # 统计出一阶矩，2-4阶中心矩
#' lbub = c(0.1,5, 2.1,10, 0.1,0.9, 0.01,0.4) # 参数搜索范围
#' # 表示：0.1 <g< 5, 2.1 <N< 10, 0.1 <mu< 0.9, 0.01 <sigma< 0.4
#' Theta = matrix(lbub, nrow=4, ncol=2, byrow=TRUE) # 从数列转换成矩阵
#' # SA 搜索，限定搜索20步，步长固定为0.01（与1/k序列不一样）
#' theta0 = c(0.25, 3.0, 0.4, 0.05)           # 初始参数值 (g, N, mu, sigma)
#' stepsize = rep(0.01, 4)                    # 步长固定为0.01
#' theta_f_record = sa(theta0, Theta, stepsize, L, moments, G=20)
#' 
sa <- function(theta0, Theta, stepsize, L, moments, G = 200L) {
    .Call(`_nj_sa`, theta0, Theta, stepsize, L, moments, G)
}

